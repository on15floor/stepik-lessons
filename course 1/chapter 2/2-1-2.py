# 2.1 Ошибки и исключения
##############################
# Вам дано описание наследования классов исключений в следующем формате.
# <имя исключения 1> : <имя исключения 2> <имя исключения 3> ... <имя исключения k>
# Это означает, что исключение 1 наследуется от исключения 2, исключения 3, и т. д.
# Или эквивалентно записи:
# class Error1(Error2, Error3 ... ErrorK):
#     pass
#
# Антон написал код, который выглядит следующим образом.
# try:
#    foo()
# except <имя 1>:
#    print("<имя 1>")
# except <имя 2>:
#    print("<имя 2>")
# ...
# Костя посмотрел на этот код и указал Антону на то, что некоторые исключения можно не ловить, так как ранее в коде
# будет пойман их предок. Но Антон не помнит какие исключения наследуются от каких. Помогите ему выйти из неловкого
# положения и напишите программу, которая будет определять обработку каких исключений можно удалить из кода.
# Важное примечание:
# В отличие от предыдущей задачи, типы исключений не созданы.
# Создавать классы исключений также не требуется
# Мы просим вас промоделировать этот процесс, и понять какие из исключений можно и не ловить, потому что мы уже ранее
# где-то поймали их предка.

ex = dict()
for i in range(int(input())):
    line = input().split()
    ex[line[0]] = line[2:]


def search_and_delete(s):
    global ex
    found = 0
    for k in ex:
        if ex[k] and s in ex[k]:
            ex[k] = None
            found += 1
            search_and_delete(k)
    if ex[s] is not None:
        found += 1
        ex[s] = None
    return found


for i in range(int(input())):
    line = input()
    if not search_and_delete(line):
        print(line)
